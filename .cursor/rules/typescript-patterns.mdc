---
description: TypeScript patterns and conventions for the Medusa2 starter project
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: true
---

# TypeScript Patterns and Conventions

## Overview

This document outlines TypeScript-specific patterns, conventions, and best practices for the Medusa2 starter project.

## Core Principles

1. **Strict Type Safety**: Use TypeScript's strict mode and avoid `any` types
2. **Explicit Interfaces**: Define clear interfaces for all data structures
3. **Generic Constraints**: Use proper generic constraints for reusable components
4. **Utility Types**: Leverage TypeScript utility types for type transformations

## Type Definition Patterns

### Interface Definitions
```typescript
// Use interfaces for object shapes
interface User {
  readonly id: string;
  name: string;
  email: string;
  status: 'active' | 'inactive';
  createdAt: Date;
  updatedAt: Date;
}

// Use type aliases for unions and computed types
type UserStatus = 'active' | 'inactive';
type UserWithoutTimestamps = Omit<User, 'createdAt' | 'updatedAt'>;
```

### API Response Types
```typescript
// Consistent API response structure
interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
}

interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// Example usage
type UsersResponse = ApiResponse<User[]>;
type PaginatedUsersResponse = PaginatedResponse<User>;
```

### Form Types
```typescript
// Form input types derived from entity types
type CreateUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;
type UpdateUserInput = Partial<CreateUserInput>;

// Form validation schemas should match these types
const createUserSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email format'),
  status: z.enum(['active', 'inactive']).default('active'),
}) satisfies z.ZodType<CreateUserInput>;
```

## Generic Patterns

### Component Props with Generics
```typescript
interface DataTableProps<T> {
  data: T[];
  columns: ColumnDef<T>[];
  onRowClick?: (row: T) => void;
  loading?: boolean;
}

export const DataTable = <T extends Record<string, any>>({
  data,
  columns,
  onRowClick,
  loading = false,
}: DataTableProps<T>) => {
  // Component implementation
};
```

### Hook Generics
```typescript
interface UseApiOptions<T> {
  onSuccess?: (data: T) => void;
  onError?: (error: Error) => void;
}

export const useApi = <T>(
  endpoint: string,
  options?: UseApiOptions<T>
) => {
  // Hook implementation with proper typing
  return useQuery<T, Error>({
    queryKey: [endpoint],
    queryFn: () => fetchData<T>(endpoint),
    onSuccess: options?.onSuccess,
    onError: options?.onError,
  });
};
```

## Utility Type Patterns

### Common Utility Types
```typescript
// Make specific fields optional
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// Make specific fields required
type RequiredBy<T, K extends keyof T> = T & Required<Pick<T, K>>;

// Deep readonly
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// Example usage
type UserWithOptionalEmail = PartialBy<User, 'email'>;
type UserWithRequiredStatus = RequiredBy<Partial<User>, 'status'>;
```

### Branded Types
```typescript
// Use branded types for IDs to prevent mixing
type UserId = string & { readonly brand: unique symbol };
type PostId = string & { readonly brand: unique symbol };

const createUserId = (id: string): UserId => id as UserId;
const createPostId = (id: string): PostId => id as PostId;

// This prevents accidentally passing a UserId where PostId is expected
```

## Error Handling Types

### Result Pattern
```typescript
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

const processUser = async (id: string): Promise<Result<User>> => {
  try {
    const user = await fetchUser(id);
    return { success: true, data: user };
  } catch (error) {
    return { success: false, error: error as Error };
  }
};
```

### Custom Error Types
```typescript
abstract class AppError extends Error {
  abstract readonly code: string;
  abstract readonly statusCode: number;
}

class ValidationError extends AppError {
  readonly code = 'VALIDATION_ERROR';
  readonly statusCode = 400;
  
  constructor(
    message: string,
    public readonly field: string
  ) {
    super(message);
  }
}

class NotFoundError extends AppError {
  readonly code = 'NOT_FOUND';
  readonly statusCode = 404;
  
  constructor(resource: string, id: string) {
    super(`${resource} with id ${id} not found`);
  }
}
```

## React Component Typing

### Component Props
```typescript
// Use interfaces for component props
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
  children: React.ReactNode;
  onClick?: () => void;
}

// Use React.FC sparingly, prefer explicit typing
export const Button = ({
  variant = 'primary',
  size = 'medium',
  disabled = false,
  loading = false,
  children,
  onClick,
}: ButtonProps) => {
  // Component implementation
};
```

### Ref Forwarding
```typescript
interface InputProps {
  label: string;
  error?: string;
  placeholder?: string;
}

export const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ label, error, placeholder, ...props }, ref) => {
    return (
      <div>
        <label>{label}</label>
        <input ref={ref} placeholder={placeholder} {...props} />
        {error && <span className="error">{error}</span>}
      </div>
    );
  }
);

Input.displayName = 'Input';
```

### Event Handlers
```typescript
interface FormProps {
  onSubmit: (data: FormData) => void;
  onChange: (field: string, value: string) => void;
}

export const Form = ({ onSubmit, onChange }: FormProps) => {
  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const formData = new FormData(event.currentTarget);
    onSubmit(formData);
  };

  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    onChange(event.target.name, event.target.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input onChange={handleInputChange} />
    </form>
  );
};
```

## Module Declaration Patterns

### Ambient Declarations
```typescript
// types/global.d.ts
declare global {
  interface Window {
    ENV: {
      API_URL: string;
      NODE_ENV: string;
    };
  }
}

// Module augmentation
declare module '@medusajs/ui' {
  interface ButtonProps {
    customProp?: string;
  }
}
```

### Type-only Imports
```typescript
// Use type-only imports when importing only types
import type { User, CreateUserInput } from './types';
import type { ComponentProps } from 'react';

// Regular imports for values
import { createUser } from './api';
import { Button } from '@medusajs/ui';
```

## Configuration Types

### Environment Variables
```typescript
interface EnvironmentConfig {
  readonly NODE_ENV: 'development' | 'production' | 'test';
  readonly API_URL: string;
  readonly DATABASE_URL: string;
  readonly REDIS_URL?: string;
}

const config: EnvironmentConfig = {
  NODE_ENV: process.env.NODE_ENV as EnvironmentConfig['NODE_ENV'],
  API_URL: process.env.API_URL!,
  DATABASE_URL: process.env.DATABASE_URL!,
  REDIS_URL: process.env.REDIS_URL,
};

// Validate required environment variables at startup
const validateConfig = (config: EnvironmentConfig): void => {
  const required: (keyof EnvironmentConfig)[] = ['NODE_ENV', 'API_URL', 'DATABASE_URL'];
  
  for (const key of required) {
    if (!config[key]) {
      throw new Error(`Missing required environment variable: ${key}`);
    }
  }
};
```

## Testing Types

### Test Utilities
```typescript
// Test helper types
type MockedFunction<T extends (...args: any[]) => any> = jest.MockedFunction<T>;

interface TestUser extends User {
  password?: string; // Only for testing
}

const createTestUser = (overrides?: Partial<TestUser>): TestUser => ({
  id: 'test-user-id',
  name: 'Test User',
  email: 'test@example.com',
  status: 'active',
  createdAt: new Date(),
  updatedAt: new Date(),
  ...overrides,
});
```

## Common Anti-Patterns to Avoid

❌ **Don't**: Use `any` type
```typescript
// Bad
const processData = (data: any) => {
  return data.someProperty;
};
```

✅ **Do**: Use proper typing
```typescript
// Good
interface DataInput {
  someProperty: string;
}

const processData = (data: DataInput) => {
  return data.someProperty;
};
```

❌ **Don't**: Use function declarations for components
```typescript
// Bad
function MyComponent(props: Props) {
  return <div>{props.children}</div>;
}
```

✅ **Do**: Use const assertions for components
```typescript
// Good
const MyComponent = (props: Props) => {
  return <div>{props.children}</div>;
};
```

❌ **Don't**: Ignore strict TypeScript settings
```typescript
// Bad - tsconfig.json
{
  "strict": false,
  "noImplicitAny": false
}
```

✅ **Do**: Use strict TypeScript settings
```typescript
// Good - tsconfig.json
{
  "strict": true,
  "noImplicitAny": true,
  "strictNullChecks": true,
  "noImplicitReturns": true
}
```

## TypeScript Configuration

### Recommended tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "exactOptionalPropertyTypes": true,
    "noImplicitReturns": true,
    "noUncheckedIndexedAccess": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "build"]
}
```

## Dependencies

TypeScript-related packages:
- `typescript`: ^5.0.0
- `@types/react`: Latest
- `@types/react-dom`: Latest
- `@types/node`: Latest
- `zod`: For runtime type validation

